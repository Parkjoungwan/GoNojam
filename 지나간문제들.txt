
func nojam11050() {
	var a int
	var b int

	fmt.Scan(&a)
	fmt.Scan(&b)
	var FacA int = 1
	var FacB int = 1
	var FacC int = 1
	for i := 1; i <= a; i++ {
		FacA *= i
	}
	for j := 1; j <= b; j++ {
		FacB *= j
	}
	for k := 1; k <= (a - b); k++ {
		FacC *= k
	}
	var resultA int
	resultA = FacA / (FacB * FacC)
	fmt.Println(resultA)
}

func nojam2743() {
	var a string
	fmt.Scan(&a)
	fmt.Println(len(a))
	for _, s := range a {
		fmt.Println(string(s)) // string은 C랑 다르게 마지막에 '\0'가 없다.
	}
}

func nojam4999() {
	var me string
	var doc string
	fmt.Scan(&me)
	fmt.Scan(&doc)
	var mecount int
	var doccount int
	for _, i := range me {
		if string(i) == "a" {
			mecount++
		}
	}
	for _, j := range doc {
		if string(j) == "a" {
			doccount++
		}
	}

	if mecount >= doccount {
		fmt.Println("go")
		return
	}
	fmt.Println("no")
}

func nojam10988() {
	var palen string
	fmt.Scan(&palen)
	var count int
	for i := 0; i < len(palen)/2; i++ {
		if palen[i] == palen[len(palen)-i-1] {
			count++
		}
	}
	if count == len(palen)/2 {
		fmt.Println(1)
	} else {
		fmt.Println(0)
	}
}
func nojam1002() {
	var x1, x2, y1, y2, r1, r2 float64
	var count int
	fmt.Scan(&count)
	for i := 0; i < count; i++ {
		fmt.Scan(&x1, &y1, &r1, &x2, &y2, &r2)
		bewTwo := (x1-x2)*(x1-x2) + (y2-y1)*(y2-y1)
		bewTwo = math.Sqrt(bewTwo)
		if x1 == x2 && y1 == y2 {
			if r1 == r2 {
				fmt.Println(-1)
			} else {
				fmt.Println(0)
			}
		} else if bewTwo == r1+r2 {
			fmt.Println(1)
		} else if bewTwo < r1+r2 {
			if math.Abs(r2-r1) > bewTwo {
				fmt.Println(0)
			} else if math.Abs(r2-r1) == bewTwo {
				fmt.Println(1)
			} else {
				fmt.Println(2)
			}
		} else if bewTwo > r1+r2 {
			fmt.Println(0)
		}
	}
}

func nojam2941() {
	var Cro string
	var count int
	var count2 int
	var dzcount int
	fmt.Scan(&Cro)
	for i := 0; i < len(Cro); i++ {
		if string(Cro[i]) == "c" {
			if i == len(Cro)-1 {
				break
			}
			if string(Cro[i+1]) == "=" || string(Cro[i+1]) == "-" {
				count++
				count2 += 2
			}
		} else if string(Cro[i]) == "d" {
			if i == len(Cro)-1 {
				break
			}
			if i == len(Cro)-1 {
				break
			}
			if string(Cro[i+1]) == "-" {
				count++
				count2 += 2
			} else if string(Cro[i+1]) == "z" {
				if i+1 == len(Cro)-1 {
					break
				}
				if string(Cro[i+2]) == "=" {
					count++
					count2++
					dzcount++
				}
			}
		} else if string(Cro[i]) == "l" {
			if i == len(Cro)-1 {
				break
			}
			if string(Cro[i+1]) == "j" {
				count++
				count2 += 2
			}
		} else if string(Cro[i]) == "n" {
			if i == len(Cro)-1 {
				break
			}
			if string(Cro[i+1]) == "j" {
				count++
				count2 += 2
			}
		} else if string(Cro[i]) == "s" {
			if i == len(Cro)-1 {
				break
			}
			if string(Cro[i+1]) == "=" {
				count++
				count2 += 2
			}
		} else if string(Cro[i]) == "z" {
			if i == len(Cro)-1 {
				break
			}
			if string(Cro[i+1]) == "=" {
				count++
				count2 += 2
			}
		}
	}
	fmt.Println((len(Cro) - count2) + (count - dzcount))
}

func nojam11726() {
	var ga [1001]int
	var N int
	fmt.Scan(&N)
	ga[1] = 1
	ga[2] = 2
	for i := 3; i <= N; i++ {
		ga[i] = ga[i-1]%10007 + ga[i-2]%10007
	}
	fmt.Println(ga[N])
}

var ans int

func nojam9663() {
	var N int
	fmt.Scan(&N)
	for i := 1; i <= N; i++ {
		var Col []int = make([]int, 15)
		Col[1] = i
		nojam9633dfs(1, N, Col)
	}
	fmt.Println(ans)
}

func nojam9633dfs(Row int, N int, Col []int) {
	if Row == N {
		ans++
	} else {
		for i := 1; i <= N; i++ {
			Col[Row+1] = i
			if nojam9633Possible(Row+1, Col) {
				nojam9633dfs(Row+1, N, Col)
			} else {
				Col[Row+1] = 0
			}
		}
	}
}

func nojam9633Possible(C int, Col []int) bool {
	for i := 1; i < C; i++ {
		if Col[i] == Col[C] {
			return false
		}
		if math.Abs(float64(Col[i]-Col[C])) == math.Abs(float64(i-C)) {
			return false
		}
	}
	return true
}


func nojam11650() {
	sc := bufio.NewScanner(os.Stdin)
	wr := bufio.NewWriter(os.Stdout)
	defer wr.Flush()

	var N int
	if sc.Scan() {
		N = toInt(sc.Bytes())
	}
	arr := make([][2]int, N)
	for i := 0; i < N; i++ {
		if sc.Scan() {
			// tmp, tmpA, tmpB는 값을 받기 위한 임시 변수
			tmp := strings.Fields(sc.Text())
			tmpA, _ := strconv.Atoi(tmp[0])
			tmpB, _ := strconv.Atoi(tmp[1])
			arr[i] = [2]int{tmpA, tmpB}
		}
	}
	sort.Sort(cusheap(arr))
	// fmt.Fprintf(wr, "\n")
	for i := 0; i < N; i++ {

		fmt.Fprintf(wr, "%d %d\n", arr[i][0], arr[i][1])
	}
}

func toInt(buf []byte) (n int) {
	for _, v := range buf {
		n = n*10 + int(v-'0')
	}
	return
}

type cusheap [][2]int

func (h cusheap) Len() int { return len(h) }
func (h cusheap) Less(i, j int) bool {
	if h[i][0] == h[j][0] {
		return h[i][1] < h[j][1]
	} else {
		return h[i][0] < h[j][0]
	}
}

func (h cusheap) Swap(i, j int) { h[i], h[j] = h[j], h[i] }

func nojam16212() {
	var N int
	fmt.Scan(&N)
	X := make([]int, N)
	for i := 0; i < N; i++ {
		fmt.Scan(&X[i])
	}
	sort.Sort(sort.IntSlice(X))
	for i := 0; i < N; i++ {
		fmt.Print(X[i], " ")
	}
}

func nojam1059() {
	var N int
	var num [1001]int
	var Luckey int
	fmt.Scan(&N)
	for i := 0; i < N; i++ {
		fmt.Scan(&Luckey)
		num[Luckey] = 1
	}
	var Unlukey int
	fmt.Scan(&Unlukey)
	var down int
	down = 0
	var up int
	var check int
	for i := 1; i < 1001; i++ {
		if num[i] == 1 && check == 0 {
			down = i
		}
		if i == Unlukey {
			check = 1
		}
		if num[i] == 1 && i == Unlukey {
			fmt.Println(0)
			return
		}
		if check == 1 && num[i] == 1 {
			up = i
			break
		}
	}
	fmt.Println(down, Unlukey, up)
	fmt.Println((Unlukey-down)*(up-Unlukey) - 1)
}